<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Werner Herzog Quote Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicon -->
  <link rel="icon" href="./favicon/favicon.ico?v=1" sizes="any">

  <style>
    :root {
      --btn-gold: #f4c542;
      --thumb-blue: #4da3ff;
      --slider-fill: var(--thumb-blue);

      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
    }

    @font-face {
      font-family: "Asphalt Scratch";
      src: url("./fonts/AsphaltScratch.woff2") format("woff2");
      font-display: swap;
    }

    @font-face {
      font-family: "They Perished";
      src: url("./fonts/TheyPerished.woff2") format("woff2");
      font-display: swap;
    }

    @font-face {
      font-family: "Special Elite";
      src: url("./fonts/SpecialElite.woff2") format("woff2");
      font-display: swap;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .container {
      max-width: 760px;
      width: min(760px, 92vw);
      padding: 24px 20px 40px;
      text-align: center;
      background: #181818;
      border-radius: 12px;
      border: 1px solid #333;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.6);
    }

    h2 {
      margin: 0 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 1.35rem;
    }

    .subtitle {
      margin: 0 0 1.4rem;
      font-size: 0.9rem;
      color: #aaa;
    }

    .sliderWrapper {
      margin: 0 0 1.4rem;
      text-align: center;
    }

    .sliderRow {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 12px;
      align-items: center;
      width: min(680px, 90vw);
      margin: 0.55rem auto 0;
    }

    .sliderLabel {
      color: var(--thumb-blue);
      font-size: 0.85rem;
      white-space: nowrap;
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--slider-fill);
      background: transparent;
      margin: 0;
      --range-progress: 40%;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(to right,
          var(--slider-fill) 0%,
          var(--slider-fill) var(--range-progress),
          #3a3a3a var(--range-progress),
          #3a3a3a 100%);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--slider-fill);
      border: 2px solid rgba(255, 255, 255, 0.35);
      margin-top: -6px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    input[type="range"]::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(to right,
          var(--slider-fill) 0%,
          var(--slider-fill) var(--range-progress),
          #3a3a3a var(--range-progress),
          #3a3a3a 100%);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--slider-fill);
      border: 2px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    input[type="range"]:focus-visible {
      outline: 2px solid rgba(77, 163, 255, 0.45);
      outline-offset: 6px;
      border-radius: 12px;
    }

    .buttons {
      display: flex;
      justify-content: center;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    button {
      appearance: none;
      border: none;
      padding: 0.75rem 1.6rem;
      border-radius: 999px;
      font-weight: 700;
      font-size: 0.95rem;
      cursor: pointer;
      transition: 0.12s;
    }

    #generateBtn {
      background: var(--btn-gold);
      color: #111;
    }

    #copyBtn {
      background: #333;
      color: #eee;
      font-size: 0.82rem;
      padding: 0.62rem 1.25rem;
    }

    #generateBtn:hover {
      background: #ffd95c;
    }

    #copyBtn:hover {
      background: #444;
    }

    .quoteCard {
      margin: 1.2rem auto;
      width: min(680px, 90vw);
      aspect-ratio: 16 / 9;
      border-radius: 14px;
      overflow: hidden;
      position: relative;
      border: 1px solid #333;
      background: #0f0f0f;
      background-size: cover;
      background-position: center;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
    }

    .quoteOverlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 30% 30%, rgba(0, 0, 0, 0.25), rgba(0, 0, 0, 0.78));
    }

    .quoteText {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 48px 44px;
      text-align: center;
      line-height: 1.12;
      color: #f2f2f2;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
      overflow: hidden;
      user-select: text;
    }

    .quoteText span {
      display: block;
      width: 100%;
      max-width: 100%;
      white-space: normal;
      word-break: normal;
      overflow-wrap: normal;
      hyphens: none;
      letter-spacing: 0.02em;
      font-size: 52px;
      font-family: inherit;
    }

    .siteMark {
      position: absolute;
      right: 14px;
      bottom: 12px;
      z-index: 3;
      font-size: 12px;
      letter-spacing: 0.02em;
      color: rgba(255, 255, 255, 0.78);
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.85);
      user-select: none;
      pointer-events: none;
      white-space: nowrap;
    }

    #copyStatus {
      margin-top: 0.6rem;
      font-size: 0.82rem;
      color: #9a9a9a;
      min-height: 1em;
    }

    canvas {
      display: none;
    }
  </style>
</head>

<body>
  <main class="container">
    <h2>Werner Herzog Quote Generator</h2>
    <p class="subtitle">Reflections on an indifferent universe</p>

    <div class="sliderWrapper">
      <strong>Herzog Scale</strong>
      <div class="sliderRow">
        <span class="sliderLabel">Wehmut</span>
        <input type="range" id="herzogScale" min="0" max="10" step="2" value="4" aria-label="Herzog Scale">
        <span class="sliderLabel">Sinnnichtigkeit</span>
      </div>
    </div>

    <div class="buttons">
      <button id="generateBtn" type="button">Generate Quote</button>
    </div>

    <div id="quoteCard" class="quoteCard" role="img" aria-label="Generated quote image">
      <div class="quoteOverlay"></div>
      <div class="quoteText">
        <span id="quoteText">Click “Generate Quote.” Or do not. The Universe is indifferent.</span>
      </div>
      <div id="siteMark" class="siteMark"></div>
    </div>

    <div class="buttons">
      <button id="copyBtn" type="button">Copy. Or Don't. It Changes Nothing.</button>
    </div>

    <div id="copyStatus"></div>

    <canvas id="renderCanvas" width="1600" height="900"></canvas>
  </main>

  <script>
    /* ----------------------------
       Config
    ---------------------------- */
    const SITE_LABEL = "thinkyfun.github.io/HerzogQuoteGenerator/";

    /* ----------------------------
       Assets
    ---------------------------- */
    const imageUrls = [
      "./images/Image1.png",
      "./images/Image2.png",
      "./images/Image3.png",
      "./images/Image4.png",
      "./images/Image5.png",
      "./images/Image6.png",
      "./images/Image7.png",
      "./images/Image8.png",
      "./images/Image9.png",
      "./images/Image10.png"
    ];

    imageUrls.forEach((u) => { const i = new Image(); i.src = u; });

    const fontChoices = ["Special Elite", "They Perished", "Asphalt Scratch"];

    /* ----------------------------
       Slider fill handling
    ---------------------------- */
    function setSliderProgress(sliderEl) {
      const min = Number(sliderEl.min || 0);
      const max = Number(sliderEl.max || 100);
      const val = Number(sliderEl.value);
      const pct = ((val - min) / (max - min)) * 100;
      sliderEl.style.setProperty("--range-progress", `${pct}%`);
    }

    /* ----------------------------
       Phrase pools (UPDATED)
    ---------------------------- */
    const openings = [
      "Consider",
      "Observe",
      "Notice",
      "Witness",
      "Do not look away from",
      "Briefly,",
      "In the silence,",
      "Look closely,",
      "Here we see",
      "Surrounded by worn-out images,",
      "Dream of",
      "Imagine",
      "For a moment,",
      "Inevitable,"
    ];

    const subjects = [
      "an empty street,",
      "this abandoned chair,",
      "the flickering light,",
      "a weary animal,",
      "the cold ground,",
      "discarded potential,",
      "chaos and darkness,",
      "the ever-receding horizon,",
      "a forgotten object,",
      "violent ennui,",
      "the unmoving landscape,",
      "the unattended doorway,",
      "a lost child,",
      "a dim corridor,"
    ];

    const observations = [
      "a plain fact of passing time,",
      "a quiet hint of decay,",
      "it does not show truth,",
      "a witness to slow collapse,",
      "dense, harsh, and ephemeral,",
      "rising from the gutter, from the carnival, from the brothel,",
      "a dinosaur that does not know it is dead,",
      "a monument to indifference,",
      "an undeniable reality,",
      "climbing from the abyss,",
      "a thin layer of ice upon a deep ocean of chaos and darkness,",
      "teetering on the edge of oblivion,",
      "an echo of wasted effort,",
      "like an ancient Greek tragedy,",
      "a caveman with a machine gun,",
      "a ledger of small defeats,"
    ];

    const shortEndings = [
      "and it asks nothing of us.",
      "and it does not change because we notice.",
      "yet we are left with only the fact of it.",
      "and it is suffocating.",
      "but we must carry on with dignity.",
      "while indifferent time lurches on.",
      "like sleep without dreams.",
      "while the day continues without explanation.",
      "and it remains, quietly, what it is.",
      "and no meaning arrives to meet it."
    ];

    const endings = [
      "and we move on, pretending it meant something.",
      "yet the world does not respond, not even with contempt.",
      "as time continues without concern for our explanations.",
      "monstrously indifferent to the presence of man.",
      "overwhelming, obscene, and it wants to kill you.",
      "so meaning dissolves, leaving only the habit of belief.",
      "while the universe remains unmoved by our brief insistence.",
      "and still we call this, “endurance,” as if it were a virtue."
    ];

    /* ----------------------------
       Non-repetition (recent history)
    ---------------------------- */
    const history = {
      openings: [],
      subjects: [],
      observations: [],
      shortEndings: [],
      endings: [],
      bgUrl: [],
      font: []
    };

    function pushHistory(key, value, maxLen) {
      if (!value) return;
      if (!history[key]) history[key] = [];
      history[key].unshift(value);
      if (history[key].length > maxLen) history[key].length = maxLen;
    }

    /* ----------------------------
       Balanced usage (equal spread)
    ---------------------------- */
    const usage = {
      openings: new Map(),
      subjects: new Map(),
      observations: new Map(),
      shortEndings: new Map(),
      endings: new Map(),
      bgUrl: new Map(),
      font: new Map()
    };

    function bumpUsage(key, value) {
      if (!value) return;
      const m = usage[key];
      if (!m) return;
      m.set(value, (m.get(value) || 0) + 1);
    }

    // Picks from least-used items, with a small "band" expansion and light jitter.
    function pickBalanced(arr, key, avoidCount = 0, maxCandidates = 6) {
      if (!arr.length) return "";

      const recent = new Set((history[key] || []).slice(0, avoidCount));
      const m = usage[key] || new Map();

      // Find minimum usage among non-recent items
      let min = Infinity;
      for (const v of arr) {
        if (recent.has(v)) continue;
        const c = m.get(v) || 0;
        if (c < min) min = c;
      }

      // If everything is "recent", ignore recency for this pick
      if (min === Infinity) {
        min = Infinity;
        for (const v of arr) {
          const c = m.get(v) || 0;
          if (c < min) min = c;
        }
      }

      const candidates = [];
      // Expand outward from min usage until we have enough candidates
      for (let band = 0; band < 8 && candidates.length < maxCandidates; band++) {
        for (const v of arr) {
          const c = m.get(v) || 0;
          const okRecent = !recent.has(v) || candidates.length === 0; // allow if we had to ignore
          if (okRecent && c === min + band) {
            candidates.push(v);
            if (candidates.length >= maxCandidates) break;
          }
        }
      }

      const pick = candidates[Math.floor(Math.random() * candidates.length)];
      bumpUsage(key, pick);
      return pick;
    }

    const randomFrom = (arr) => arr[Math.floor(Math.random() * arr.length)];

    // Retained (still used by pickOpening's internal logic fallbacks if needed)
    function pickNonRepeating(arr, recentKey, avoidCount, maxTries = 60) {
      if (!arr.length) return "";
      if (!history[recentKey]) history[recentKey] = [];
      const avoid = new Set(history[recentKey].slice(0, avoidCount));
      for (let i = 0; i < maxTries; i++) {
        const candidate = randomFrom(arr);
        if (!avoid.has(candidate)) return candidate;
      }
      return randomFrom(arr);
    }

    /* ----------------------------
       Consecutive quote repetition rule
    ---------------------------- */
    let lastParts = null;

    function repeatedPartCount(a, b) {
      if (!a || !b) return 0;
      const fields = ["o", "s", "obs", "e"];
      let count = 0;
      for (const f of fields) {
        const av = (a[f] || "").trim();
        const bv = (b[f] || "").trim();
        if (av && bv && av === bv) count++;
      }
      return count;
    }

    const singleWordOpenings = new Set(["Consider", "Observe", "Notice", "Witness"]);
    let lastOpeningWasSingle = false;

    function pickOpening() {
      // Use balanced selection but keep your "no consecutive single-word openings" rule.
      let o = pickBalanced(openings, "openings", 4, 6);

      if (lastOpeningWasSingle) {
        for (let i = 0; i < 20; i++) {
          const candidate = pickBalanced(openings, "openings", 4, 6);
          if (!singleWordOpenings.has(candidate)) { o = candidate; break; }
        }
      }

      lastOpeningWasSingle = singleWordOpenings.has(o);
      return o;
    }

    function buildQuoteOnce(scale) {
      const o = pickOpening();
      const s = pickBalanced(subjects, "subjects", 3, 6);

      if (scale <= 2) {
        const e = pickBalanced(shortEndings, "shortEndings", 3, 6);
        return { quote: [o, s, e].join(" "), parts: { o, s, obs: "", e }, tier: "short" };
      }

      const obs = pickBalanced(observations, "observations", 3, 6);

      if (scale <= 6) {
        const e = pickBalanced(shortEndings, "shortEndings", 3, 6);
        return { quote: [o, s, obs, e].join(" "), parts: { o, s, obs, e }, tier: "medium" };
      }

      const e = pickBalanced(endings, "endings", 3, 6);
      return { quote: [o, s, obs, e].join(" "), parts: { o, s, obs, e }, tier: "long" };
    }

    function buildQuote(scale) {
      const maxAttempts = 30;
      for (let i = 0; i < maxAttempts; i++) {
        const built = buildQuoteOnce(scale);
        if (!lastParts) return built;
        if (repeatedPartCount(built.parts, lastParts) <= 2) return built;
      }
      return buildQuoteOnce(scale);
    }

    /* ----------------------------
       State + render
    ---------------------------- */
    const state = { quote: "", bgUrl: "", font: "" };

    function applyQuoteCard() {
      const card = document.getElementById("quoteCard");
      const text = document.getElementById("quoteText");
      const siteMark = document.getElementById("siteMark");

      if (state.bgUrl) card.style.backgroundImage = `url("${state.bgUrl}")`;
      text.style.fontFamily = `"${state.font}", system-ui, sans-serif`;
      text.textContent = state.quote;

      siteMark.textContent = SITE_LABEL;
      document.getElementById("copyStatus").textContent = "";
    }

    function getInnerBox(el) {
      const cs = getComputedStyle(el);
      const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
      const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
      return { w: el.clientWidth - padX, h: el.clientHeight - padY };
    }

    function fitQuoteTextToCard() {
      const wrapper = document.querySelector(".quoteText");
      const textEl = document.getElementById("quoteText");
      const { w: maxW, h: maxH } = getInnerBox(wrapper);
      if (maxW <= 0 || maxH <= 0) return;

      textEl.style.maxWidth = maxW + "px";

      let lo = 18, hi = 84, best = lo;
      const fits = (size) => {
        textEl.style.fontSize = size + "px";
        return textEl.scrollWidth <= maxW + 1 && textEl.scrollHeight <= maxH + 1;
      };

      if (fits(hi)) { textEl.style.fontSize = hi + "px"; return; }

      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        if (fits(mid)) { best = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }
      textEl.style.fontSize = best + "px";
    }

    let generating = false;

    async function generate() {
      if (generating) return;
      generating = true;

      try {
        const scaleEl = document.getElementById("herzogScale");
        const scale = Number(scaleEl.value);
        setSliderProgress(scaleEl);

        const built = buildQuote(scale);
        state.quote = built.quote;

        // Balanced selection for backgrounds and fonts
        state.bgUrl = pickBalanced(imageUrls, "bgUrl", 2, 4);
        state.font = pickBalanced(fontChoices, "font", 2, 3);

        try { await document.fonts.load(`48px "${state.font}"`); } catch { }

        applyQuoteCard();
        requestAnimationFrame(() => fitQuoteTextToCard());

        // Keep recent-history tracking for anti-repeat smoothing
        pushHistory("openings", built.parts.o, 10);
        pushHistory("subjects", built.parts.s, 6);
        if (built.parts.obs) pushHistory("observations", built.parts.obs, 6);

        if (built.tier === "long") pushHistory("endings", built.parts.e, 6);
        else pushHistory("shortEndings", built.parts.e, 6);

        pushHistory("bgUrl", state.bgUrl, 4);
        pushHistory("font", state.font, 4);

        lastParts = { ...built.parts };
      } finally {
        generating = false;
      }
    }

    /* ----------------------------
       Canvas export (copy/share)
    ---------------------------- */
    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    function drawCover(ctx, img, w, h) {
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const s = Math.max(w / iw, h / ih);
      const sw = iw * s, sh = ih * s;
      const sx = (w - sw) / 2, sy = (h - sh) / 2;
      ctx.drawImage(img, sx, sy, sw, sh);
    }

    function wrapLines(ctx, text, maxWidth) {
      const words = text.split(/\s+/);
      const lines = [];
      let line = "";
      for (const word of words) {
        const test = line ? (line + " " + word) : word;
        if (ctx.measureText(test).width <= maxWidth) line = test;
        else {
          if (line) lines.push(line);
          line = word;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function drawSiteMark(ctx, W, H) {
      const pad = Math.round(W * 0.018);
      const fontSize = Math.max(18, Math.round(W * 0.014));

      ctx.save();
      ctx.textAlign = "right";
      ctx.textBaseline = "alphabetic";
      ctx.font = `600 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

      ctx.shadowColor = "rgba(0,0,0,0.85)";
      ctx.shadowBlur = 18;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillText(SITE_LABEL, W - pad, H - pad);

      ctx.restore();
    }

    async function renderQuoteToCanvas() {
      const canvas = document.getElementById("renderCanvas");
      const ctx = canvas.getContext("2d");
      const W = canvas.width, H = canvas.height;

      ctx.clearRect(0, 0, W, H);

      const bg = await loadImage(state.bgUrl);
      drawCover(ctx, bg, W, H);

      const grd = ctx.createRadialGradient(W * 0.30, H * 0.30, 10, W * 0.30, H * 0.30, Math.max(W, H));
      grd.addColorStop(0, "rgba(0,0,0,0.25)");
      grd.addColorStop(1, "rgba(0,0,0,0.78)");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);

      const padX = Math.round(W * 0.065);
      const padY = Math.round(H * 0.125);
      const maxTextWidth = W - padX * 2;
      const maxTextHeight = H - padY * 2;

      let fontSize = 84;
      const minFont = 24;

      try { await document.fonts.load(`${fontSize}px "${state.font}"`); } catch { }

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const fits = (size) => {
        ctx.font = `700 ${size}px "${state.font}", system-ui, sans-serif`;
        const lines = wrapLines(ctx, state.quote, maxTextWidth);
        const lineHeight = Math.round(size * 1.15);
        return (lines.length * lineHeight) <= maxTextHeight;
      };

      while (fontSize > minFont && !fits(fontSize)) fontSize -= 2;

      ctx.font = `700 ${fontSize}px "${state.font}", system-ui, sans-serif`;
      const lines = wrapLines(ctx, state.quote, maxTextWidth);
      const lineHeight = Math.round(fontSize * 1.15);
      const totalHeight = lines.length * lineHeight;

      ctx.shadowColor = "rgba(0,0,0,0.85)";
      ctx.shadowBlur = 18;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;

      ctx.fillStyle = "#f2f2f2";

      const startY = (H / 2) - (totalHeight / 2) + (lineHeight / 2);
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], W / 2, startY + i * lineHeight);
      }

      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      drawSiteMark(ctx, W, H);

      return canvas;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function canvasToPngBlob(canvas) {
      if (canvas.toBlob) {
        const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png", 0.92));
        if (!blob) throw new Error("PNG blob creation failed");
        return blob;
      }
      const dataUrl = canvas.toDataURL("image/png");
      const res = await fetch(dataUrl);
      const blob = await res.blob();
      if (!blob || !blob.size) throw new Error("PNG blob creation failed (fallback)");
      return blob;
    }

    async function copyQuoteImage() {
      const status = document.getElementById("copyStatus");
      status.textContent = "";

      let blob;
      try {
        const canvas = await renderQuoteToCanvas();
        blob = await canvasToPngBlob(canvas);
      } catch {
        status.textContent = "Could not export image — try generating again.";
        setTimeout(() => { status.textContent = ""; }, 2200);
        return;
      }

      if (navigator.clipboard && window.ClipboardItem) {
        try {
          await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
          status.textContent = "Copied image to clipboard.";
          setTimeout(() => { status.textContent = ""; }, 2200);
          return;
        } catch { /* fall through */ }
      }

      try {
        const file = new File([blob], "herzog-quote.png", { type: "image/png" });
        if (navigator.canShare && navigator.canShare({ files: [file] }) && navigator.share) {
          await navigator.share({ files: [file], title: "Herzog-ish Oracle" });
          status.textContent = "Opened share sheet.";
          setTimeout(() => { status.textContent = ""; }, 2200);
          return;
        }
      } catch { /* fall through */ }

      downloadBlob(blob, "herzog-quote.png");
      status.textContent = "Downloaded PNG instead.";
      setTimeout(() => { status.textContent = ""; }, 2200);
    }

    /* ----------------------------
       Wire up UI
    ---------------------------- */
    const scaleEl = document.getElementById("herzogScale");

    document.getElementById("generateBtn").addEventListener("click", (e) => {
      e.preventDefault();
      generate();
    });

    document.getElementById("copyBtn").addEventListener("click", (e) => {
      e.preventDefault();
      copyQuoteImage();
    });

    scaleEl.addEventListener("input", () => {
      setSliderProgress(scaleEl);
      generate();
    });

    window.addEventListener("resize", () => requestAnimationFrame(fitQuoteTextToCard));

    setSliderProgress(scaleEl);
    generate();
  </script>
</body>

</html>
